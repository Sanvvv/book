# TCP/IP 协议分层模型
## 分层

- 应用层
  - 作用：网络应用程序所在，并定义通信（协议）和交互（C/S等）规则
  - 传输单位：报文（message）= Appl首部 + 用户数据
  - 协议：HTTP、FTP

- 传输层：
  - 作用：负责在两个（不同主机的）应用程序端点之间传递报文
  - 传输单位：报文段（TCP）、用户数据报（UDP）= TCP/UDP首部 + 报文
  - 协议：TCP、UDP

- 网络层：
  - 作用：将数据报从一台主机传到另一台主机上（只负责提供源地址和目的地址的位置?）
  - 传输单位：数据报（datagram）= IP首部 + 报文段/用户数据段
  - 协议：IP

- 链路层
  - 作用：负责与链路（传输媒介）的数据传输工作，将帧从当前节点移动到下一个节点（具体的传输过程）
  - 传输单位：帧（frame）= 以太网首部 + IP数据报 + 以太网尾部
  - 协议：SDLC、HDLC、PPP、STP、帧中继

- 物理层：
  - WiFi、4G

# 应用层
## HTTP

Hyper Text Transfer Protocol（超文本传输协议）

### 状态码

200 & OK: 请求成功；

204 & No Content: 请求处理成功，但没有资源可以返回；

206 & Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)；

301 & Move Permanently: 永久性重定向；

302 & Found： 临时性重定向；

303 & See Other: 请求资源存在另一个URI，应使用get方法请求；

304 & Not Modified: 服务器判断本地缓存未更新，可以直接使用本地的缓存；

307 & Temporary Redirect: 临时重定向；

400 & Bad Request: 请求报文存在语法错误；

401 & Unauthorized: 请求需要通过HTTP认证；

403 & Forbidden: 请求资源被服务器拒绝，访问权限的问题；

404 & Not Found: 服务器上没有请求的资源；

500 & Internal Server Error: 服务器执行请求时出现错误；

502 & Bad Gateway: 错误的网关；

503 & Service Unavailable: 服务器超载或正在维护，无法处理请求；

504 & Gateway timeout: 网关超时；

### Cookie & Session & Token

[https://www.zhihu.com/question/19786827/answer/28752144]

#### Cookie

存于浏览器中，4kb，每次请求都会携带 cookie ，不安全（document.cookie）

HttpOnly

设置：Set-Cookie

#### Session

用于保存会话数据，存于服务端中

第一次请求时，服务端会创建一个 session 对象，并将键（cookie）返回给浏览器，下一次访问的时候携带 cookie 就可以找到对应的 session（值）

#### Token

### 首部

[1](https://yuchengkai.cn/docs/zh/cs/#http-%E9%A6%96%E9%83%A8)

### GET & POST

- 在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册
- GET 能被缓存，POST 不能缓存
- GET 编码类型 application/x-www-form-url，POST 编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
- GET 受 URL 长度限制（URL 的最大长度是 2048 个字符），POST无限制
- GET 只允许 ASCII 字符。POST 没有数据类型的限制，也允许二进制数据
- Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的

## HTTP 2.0
### 二进制传输

HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

### 多路复用

在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### Header 压缩

在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

### 服务端 Push

在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。

可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。

### QUIC

这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。

- 该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制
- 实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了
- 支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包
  - 纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包
  - 在丢失两个包或以上的情况就使用重传机制，因为算不出来了

## DNS

Domain Name System（域名系统），运行在 UDP 协议上，用于转换 ip 和域名

采用分布式的设计方案，如果本地的 DNS 服务器上找不到对应的地址的话就会再往上级传

通过修改 host 可以直接在本地进行域名和 ip 的转换

# 传输层
## 端口

protocol，用于区分主机的不同进程（?），大小在 0-65535 之间

FTP：21，TELNET：23，SMTP：25，DNS：53，TFTP：69，HTTP：80，HTTPS：443，SNMP：161

登记端口号：1024-49151，客户端使用的端口号：49152-65535

## UDP

User Datagram Protocol

基于 UDP 的协议：DHCP（67）、DNS（53）、TFTP、RIP、BOOTP、SNMP、NFS

### 面向报文

可以理解为只是报文的搬运工，不会对报文进行任何拆分和拼接操作（传输单个数据报），只是添加了一个 UDP 头

大小为 1500 - 20（IP数据报首部） - 8（UDP首部）= 1472字节

> 实际实现中会先计算 IP?

UDP 首部只占用 8 个字节（源端口号、目的端口号、长度、校验和），顶部的 12 个字节的伪首部是用于计算 UDP 首部校验和（并不出现在实际传送的数据中）

### 不可靠性

- 无连接：不需要建立和断开连接
- 不可靠的：协议收到什么数据就传递什么，也不会备份
- 无法确认是否送达：但是接收端可以校验内容是否正确
- 没有拥塞控制：会以恒定的速度发送数据，网络拥塞时会导致丢包，优点是比较适合实时性要求高的场景

### 高效

UDP 头只占 8 字节，开销小，并且无连接，在传输过程中相当高效

### 传输方式

支持一对多，多对多，多对一的方式，也就是说提供了单播，多播，广播的功能

## TCP

Transmission Control Protocol，面向连接，可靠传输，流式

TCP 首部占用 60 字节（5*4 + 选项部分40），包含：源端口号、目的端口号、序号、确认序号、数据偏移（报文段首部长度） + 保留 + 标志位、窗口大小、校验和、紧急指针（配合 URG flag 表示需要尽快传送）

[tcp header](https://camo.githubusercontent.com/cc4d7fb7c85dcddbb38e4c5b2b5daf796768a109/687474703a2f2f6f6d366179726166752e626b742e636c6f7564646e2e636f6d2f706f73742f756e6465727374616e642d7463702d7564702f43464336333134453442324644303339433435303832314439343645393345322e706e67)

### 序号

32位（4字节），指报文段数据中第一个字节的序号，可表示 2^32 即 4GB 数据，超出后将回到 0。

TCP 通过序号来保证报文是有序的，对端通过序号的顺序来拼接报文。

### 确认序号

32位，表示期望收到对方下一个报文段的序号值，同时也表示上一个序号的数据已经收到。

### 标志位

- URG=1：表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部
- ACK=1：表明为确认报文段，在连接建立后所有传送的报文段都需要把 ACK 置为 1
- PSH=1：表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付
- RST=1：表示 TCP 连接中出现严重错误，需要释放并重新建立连接，也可以用于拒绝非法的报文段或者连接请求
- SYN=1：ACK=0 的时候表明是一个请求连接报文段；ACK=1 的时候表明是一个同意建立连接的应答报文；在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号
- FIN=1：表示对端的数据已经发送完毕，请求释放连接

### 窗口大小

占 2 字节，指出 TCP 接收缓冲区还能容纳多少字节的数据（从确认序号算起），用于流量控制。

### 三次握手

为什么 2 次握手不行：为了确保客户端能收到服务端的信息，以避免第一次连接请求延迟到达但是同样建立连接的问题（客户端需要发一次 ACK=1）

连接步骤：

0. 服务端打开 socket 开始监听连接（被动打开）
  - 进入 LISTEN 状态
1. 客户端向服务端发送一个 SYN 请求报文来主动打开连接
  - 进入 SYN_SEND 状态
  - 序号为随机设定的 A
  - SYN 报文段不带数据，但是会消耗一个序号
2. 服务端收到报文后，如果同意建立连接则返回一个 SYN/ACK 确认报文
  - 进入 SYN_RCVD 状态
  - 序号为随机设定的 B，确认序号为 A+1
3. 客户端收到报文后，返回一个 ACK 确认报文
  - 进入 ESTABLISHED 状态
  - 序号为 A+1，确认序号为 B+1（因为被 SYN 消耗了一个序号所以最终都加了 1）
  - 这个时候一般会携带真正需要传输的数据，如果服务器也收到该数据报文就会同样进入 ESTABLISHED 状态，此时 TCP 连接建立完成

确定超时总共需要：1 + 2 + 4 + 8 + 16 + 32 = 63s

### 四次挥手

TCP 是全双工（可以同时发送和接收）连接，关闭连接的时候必须关闭传送和接收两个方向上的连接（只关一个时处于半关闭状态），这也是 2 次挥手不行的原因

关闭步骤：

1. 客户端向服务端发送 FIN 结束报文段
  - 进入 FIN_WAIT_1 状态
  - FIN = 1，序号 = C
2. 服务端收到结束报文段，返回 ACK 确认报文段
  - 进入 CLOSE_WAIT  状态
  - ACK = 1，序号 = C + 1
  - 客户端收到该报文，会进入 FIN_WAIT_2 状态
3. 服务端向客户端发送 FIN 结束报文段
  - 进入 LAST_ACK 状态
  - FIN = 1，序号 = D
4. 客户端收到结束报文段，返回 ACK 确认报文段
  - 进入 TIME_WAIT 状态，并在 2MSL 后自动进入 CLOSED 状态
  - ACK = 1，序号 = D + 1
  - 服务端收到该报文，会进入 CLOSED 状态

MSL：最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值为 2 分钟

### 滑动窗口协议

头部的 window 字段代表接收端还有多少缓冲区可以接收数据，于是发送端就可以根据窗口大小来发送数据

滑动窗口分为发送窗口和接收窗口，由于 TCP 协议是全双工的，所以需要同时维护两者

#### 发送窗口

包含已发送但未收到应答的数据和可以发送但是未发送的数据，大小取决于对端通告的接收窗口（剩余大小）

对于发送窗口，缓存内的数据有四种状态：

- #1 已发送，并得到接收方 ACK 确认
- #2 已发送，但还未收到接收方 ACK
- #3 未发送，但接收方允许发送，接收方还有空间
- #4 未发送，且接收方不允许发送，接收方没有空间
- #2 + #3 === 发送窗口大小 === 接收窗口大小

狸子：收到接收方对于 32-36 字节序的数据包的 ACK 确认后，窗口就会往右移动 5 个字节位置（被确认的部分会到 #1），并发送移动前 #3 中的数据（46-51 字节），之后 #3 中的数据变成 52-56（5个字节）

#### 接收窗口

大小取决于应用、系统、硬件的限制

接收窗口在缓存内只有三种状态：

- #1 已接收已确认
- #2 未接收，准备接收
- #3 未接收，并未准备接收

与发送端不同的是接收端只有在前面的段都确认时才会移动边界

#### Zero 窗口

在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。

### 超时重传
#### 重传超时时间 RTO

指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间

#### 连接往返时间 RTT

指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间

TCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO，这个估值算法称为自适应重传算法

#### 停止等待 ARQ

TCP 每发送一个报文段，就会对这个报文段设置一次计时器（一般大于平均RTT）。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段。

情况（总之就是没收到 ACK）：

1. 数据包中途丢失
2. 数据包到达但是对方未响应 ACK 或包被丢弃
3. 数据包到达但是对方的 ACK 丢失

#### 连续 ARQ

在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。

并且在收到多个报文之后统一回复一个应答报文。

但是也存在弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据（可以通过 Sack 解决）。

### 拥塞控制

作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况

#### 慢开始

在传输开始时将发送窗口慢慢指数级扩大（每过一个 RTT 窗口大小 * 2）

1. 连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）
2. 每过一个 RTT 就将窗口大小乘二
3. 指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法

#### 拥塞避免

每过一个 RTT 窗口大小只加一，慢慢将大小调整到最佳值

在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：

1. 将阈值设为当前拥塞窗口的一半
2. 将拥塞窗口设为 1 MSS
3. 启动拥塞避免算法

#### 快速重传

一般和快恢复一起出现；一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）；如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传

TCP Taho：

1. 将阈值设为当前拥塞窗口的一半
2. 将拥塞窗口设为 1 MSS
3. 重新开始慢开始算法

TCP Reno：

1. 拥塞窗口减半
2. 将阈值设为当前拥塞窗口
3. 进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）
4. 使用拥塞避免算法

#### TCP New Ren 改进后的快恢复

TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。

在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。

假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。

## 广播、多播（组播）

广播：发送给 255 端口（只能在局域网广播?）

多播：类似频道

## Socket

open -> write/read -> close

## VPN

会虚拟一张网卡，能够连接到 VPN 服务器的内网

## 公私钥

双方分别持有 S1 P2、S2 P1，S 是 私钥，P 是告诉对方的公钥；将数据用 S1 P2 加密，再用 P1 S2 解密，就可以得到数据

## 证书

将证书信息算一遍 MD5 得到 hash，再用私钥加密得到签名（sign）；接下来只需要用提供的公钥解开签名，能得到一致的 hash，就说明认证成功

# 网络层

网络层负责把 IP 数据包（Packet）从起始机器送至目标机器

## IP

负责主机之间的通信，但是不保证数据能送达并且完整（不可靠服务）

### 数据报

包含：生成时间、源地址、目的地址

生存时间减为 0 时会把数据丢掉，并由当前地址给源地址发送一条响应（可以用来探测路径）

### 分类

A、B、C、广播地址

### IPV6

3 * 10 ^ 38

路由器不支持

## NAT

Net Address Translation

### DMZ

发给 NAT 路由器的数据如果不知道发给谁就会发给指定的端口

### uPnP

广域网上的任何程序都可以通过路由器的某个端口连接到内部网络的地址（本来的需要先和外部通信一次才能处理这个端口）

## DHCP

Dynamic Host Configuration Protocol（动态主机配置协议）

建立过程：

1. 客户端通过广播发送 DHCP discover 消息，所有 DHCP 服务器都将接收这个消息
2. 服务器通过广播回应一个 DHCP offer 消息（以第一个为准）
3. 客户端通过广播发送 DHCP request 消息，包含申请的 ip 地址，并通知其他服务器不必响应
4. 服务器回应 DHCP ACK 消息

## 路由器

- 能让两个 IP 不同的主机通信（?）
- 路由器会根据网络结构选择如何转发分组
  - 各种路由协议
  - 路由表
- 家用路由器其实是 NAT 路由器
  - NAT 网络地址转换

## 子网掩码

255.0.0.0 / 8 

## 默认网关

一台主机如果找不到可用的网关，就会把数据包发给默认指定的网关

## ICMP

- ping 就属于 ICMP
- TTL 超时（type 11 code 0）

## VPN

一般的 VPN 连接后电脑会多出一个 IP 地址（某种程度上相当于把网线插到了 VPN 目标所在位置）

## else

- tracert
- find gfw location
- nslookup

# 链路层

- 负责直接连接（局域网）的设备（主机、路由器）之间的通信
- 只关心两台机器之间的信号
- 由于线路上会连接多个设备所以需要 MAC 地址来区分

## 帧

- 数据包在链路层中被称作帧
- 802.3以太网帧结构...

## 局域网的组成方式

- 以太网：多台电脑连接到一根总线上（最简单的实现）/ 载波侦听多路访问 / 总线型 / 分时复用
- WiFi：载波侦听多路访问
- 广播：心形网络，全部都收到
- 环形网络
- 令牌环：一个个传递，是自己的接收，不是就继续传
- 交换机：将数据传给正确的 MAC 地址对应的电脑 / 二层（只认 MAC 和帧）

## MAC地址

- 给每一个网卡物理地址
- 一台电脑有多张网卡的话就可以有多个 MAC 地址
- ARP 协议：将 IP 解析为 MAC 地址

## ARP

Address Resolution Protocol，将 ip 地址解析为 MAC 地址

# 物理层

- 指设备之间的物理连接（网线、光纤、wifi、4g）
- 解决信号的调制与解调（数字信号与模拟信号的转换和传输）
- 保证通信两端能够理解01
- 把上层给到的数据转换为表示01的模拟信号传到电缆上
- 把从电缆接收到的数据转换为01

## 需要考虑

- 信号的时钟同步：差分曼彻斯特编码（下降表示1上升表示0），但是会额外多用跳变次数（数据降半，因为还编码了时钟周期的信息）
- 电压（流）的大小（5V）

## 无线网

2.4GHz，同一时刻只能有一个设备发送或者接收数据（但是其实可以有多频道?）





